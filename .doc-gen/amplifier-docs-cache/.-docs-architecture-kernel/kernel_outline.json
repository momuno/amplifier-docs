{
  "_meta": {
    "name": "kernel-philosophy-outline",
    "document_instruction": "Explain kernel philosophy, boundaries, evolution rules, and decision frameworks following Linux kernel-inspired principles. Use clear prose, tables, and code examples to illustrate mechanism vs policy boundaries and evolution principles.",
    "model": "claude-sonnet-4-20250514",
    "max_response_tokens": 8000,
    "temperature": 0.3
  },
  "document": {
    "title": "Kernel Philosophy",
    "output": "architecture-kernel.md",
    "sections": [
      {
        "heading": "# Kernel Philosophy",
        "level": 1,
        "prompt": "Introduce the Amplifier kernel philosophy explaining it follows principles inspired by the Linux kernel: provide mechanisms, not policy. Set the stage for understanding kernel design decisions.",
        "sources": [
          {
            "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
            "reasoning": "Lines 1-7 establish the document's purpose as the complete design philosophy guiding all development, and lines 11-14 introduce the core 'Mechanism, Not Policy' principle that defines kernel philosophy",
            "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
          }
        ],
        "sections": [
          {
            "heading": "## Core Tenets",
            "level": 2,
            "prompt": "Introduce the four core tenets that define the kernel philosophy: Mechanism Not Policy, Small Stable and Boring, Don't Break Modules, and Extensibility Through Composition.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 9-45 define the six core principles including the four main kernel tenets, establishing the foundational philosophy",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": [
              {
                "heading": "### 1. Mechanism, Not Policy",
                "level": 3,
                "prompt": "Explain that the kernel exposes capabilities and stable contracts while decisions about behavior belong outside the kernel. Include the table contrasting what kernel does (mechanism) vs doesn't (policy), and provide the litmus test: if two teams could want different behavior, it's policy and should stay out of kernel.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 11-14 define the Mechanism Not Policy principle with clear examples of what belongs in kernel (capabilities, contracts) vs modules (behavior decisions like provider selection, orchestration strategy)",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 1-13 explain coordinator's role in providing infrastructure context (identifiers, basic state) embodying 'minimal context plumbing' from kernel philosophy, demonstrating mechanism provision",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 2. Small, Stable, and Boring",
                "level": 3,
                "prompt": "Explain that the kernel is intentionally minimal (~2,600 lines) and changes rarely. Define the three characteristics: Small (can be audited in an afternoon), Stable (backward compatibility is sacred), Boring (no clever tricks, no surprises).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 22-26 define the 'Small, Stable, Boring Kernel' principle emphasizing that kernel changes rarely, maintains backward compatibility, favors deletion over accretion, and innovation happens at edges (modules)",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 3. Don't Break Modules",
                "level": 3,
                "prompt": "Explain that backward compatibility in kernel interfaces is sacred. List the three principles: additive evolution only, clear deprecation with migration paths, and long sunset periods for changes.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 134-137 define backward compatibility as sacred with specific requirements: kernel changes must not break existing modules, clear deprecation notices with dual-path support, and long sunset periods",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 4. Extensibility Through Composition",
                "level": 3,
                "prompt": "Explain that new behavior comes from plugging in different modules, not from toggling flags. Show the code comparison contrasting configuration explosion (anti-pattern with flags) vs composition (mounting different modules).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 28-32 define Modular Design (Bricks & Studs) with emphasis on composition over configuration, and lines 141-180 detail the module design philosophy with self-contained bricks and interface studs",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/loader.py",
                    "reasoning": "Lines 29-38 define TYPE_TO_MOUNT_POINT mapping showing kernel mechanism for module composition: modules declare type, kernel derives mount point, enabling plug-and-play extensibility without flags",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              }
            ]
          },
          {
            "heading": "## What Belongs in the Kernel",
            "level": 2,
            "prompt": "Introduce the distinction between kernel responsibilities (mechanisms) and kernel non-goals (policies), establishing clear boundaries for what should and should not be in the kernel.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 96-112 explicitly define kernel vs module boundaries listing what kernel does (mechanisms) and what kernel NEVER does (policies)",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": [
              {
                "heading": "### Kernel Responsibilities (Mechanisms)",
                "level": 3,
                "prompt": "List and explain the kernel's mechanism responsibilities: stable contracts (protocol definitions), lifecycle coordination (load/unload/mount/unmount), event emission (canonical events for observability), capability enforcement (permission checks, approvals), and minimal context (session IDs, basic state).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 98-105 list kernel responsibilities as mechanisms: stable contracts, module loading/unloading, event dispatch, capability checks, and minimal context plumbing",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 39-79 implement ModuleCoordinator showing kernel mechanisms in practice: mount points for module attachment, infrastructure context (IDs, config, session reference), capability registry for inter-module communication, and event system",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/loader.py",
                    "reasoning": "Lines 47-60 document ModuleLoader class implementing lifecycle coordination mechanism: discovering and loading modules with support for entry points, environment variables, and filesystem paths",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### Kernel Non-Goals (Policies)",
                "level": 3,
                "prompt": "List and explain what the kernel explicitly avoids: orchestration strategies, provider/model selection, tool behavior or domain rules, output formatting, logging destinations, and business defaults.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 107-112 explicitly list what kernel NEVER does as policies: select providers or models, decide orchestration strategy, choose tool behavior, format output or pick logging destination, make product decisions",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 35-36 show kernel provides mechanism (injection limits configurable) but not policy (default: None/unlimited), and lines 86-90 show kernel doesn't decide fallback behavior when systems not provided - that's app-layer policy",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              }
            ]
          },
          {
            "heading": "## Invariants",
            "level": 2,
            "prompt": "Document the five invariants that must always hold: backward compatibility (existing modules work across kernel updates), non-interference (faulty modules can't crash kernel), bounded side-effects (kernel doesn't make irreversible external changes), deterministic semantics (same inputs = same behavior), and minimal dependencies (no transitive dependency sprawl).",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "While the markdown doc doesn't have an explicit 'Invariants' section, lines 134-137 establish backward compatibility as sacred, and lines 16-20 on Ruthless Simplicity imply minimal dependencies and bounded complexity",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              },
              {
                "file": "amplifier_core/loader.py",
                "reasoning": "Lines 41-44 define ModuleValidationError showing kernel enforces validation at load time, protecting against module failures (non-interference invariant)",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": []
          },
          {
            "heading": "## Evolution Rules",
            "level": 2,
            "prompt": "Introduce the four rules governing how the kernel evolves: Additive First, Two-Implementation Rule, Spec Before Code, and Complexity Budget.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 123-137 define evolution rules emphasizing additive evolution, two-implementation rule, and backward compatibility as sacred principles for kernel changes",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": [
              {
                "heading": "### 1. Additive First",
                "level": 3,
                "prompt": "Explain extending contracts without breaking them by preferring optional capabilities. Show code examples contrasting good (optional new parameter with default) vs bad (required new parameter that breaks existing providers).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 125-128 define additive evolution: extend schemas with optional fields, provide deprecation windows for removals, ensuring backward compatibility through additive-only changes",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "amplifier_core/interfaces.py",
                    "reasoning": "Lines 1-11 establish Protocol-based interfaces using structural subtyping (no inheritance required), enabling additive evolution where new optional methods can be added without breaking existing implementations",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 2. Two-Implementation Rule",
                "level": 3,
                "prompt": "Explain that concepts shouldn't be promoted into kernel until \u22652 independent modules converge on the need. Show the progression: Module A needs X (prototype in A), Module B needs X (prototype in B), A and B converge (extract X to kernel).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 130-132 define the two-implementation rule: need from \u22652 independent modules before adding to kernel, proves the mechanism is actually general and not premature abstraction",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 3. Spec Before Code",
                "level": 3,
                "prompt": "Explain that kernel changes begin with a short spec covering: purpose, alternatives considered, impact on invariants, test strategy, and rollback plan.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 313-326 define kernel change acceptance criteria requiring evidence, invariant preservation, interface design, tests and docs, showing spec-first approach to kernel evolution",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### 4. Complexity Budget",
                "level": 3,
                "prompt": "Explain that each kernel change must justify its complexity and additions should retire equivalent complexity elsewhere.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 16-20 emphasize ruthless simplicity with 'Code you don't write has no bugs', and line 326 states additions must retire equivalent complexity elsewhere, establishing complexity budget principle",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              }
            ]
          },
          {
            "heading": "## Interface Guidance",
            "level": 2,
            "prompt": "Introduce guidance for designing kernel interfaces focusing on three principles: Small and Sharp, Stable Schemas, and Explicit Errors.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 40-44 establish text-first, inspectable principles with explicit over implicit, setting foundation for interface design guidance",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": [
              {
                "heading": "### Small and Sharp",
                "level": 3,
                "prompt": "Explain preferring few, precise operations over broad, do-everything calls. Show code examples contrasting good (focused operations like mount/unmount) vs bad (swiss army knife method with operation parameter).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 16-20 on ruthless simplicity emphasize minimizing abstractions and keeping interfaces simple and focused",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 39-79 demonstrate small, sharp interfaces in ModuleCoordinator: separate mount points for each module type, focused methods for capability registry, clean separation of concerns rather than one monolithic interface",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### Stable Schemas",
                "level": 3,
                "prompt": "Explain versioning any data shapes crossing kernel boundaries. Show example of versioned request format with schema_version field and how new fields are optional with defaults (e.g., temperature added in v1.1).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/message_models.py",
                    "reasoning": "Message models like ChatRequest use Pydantic BaseModel for schema validation and versioning, demonstrating stable schema patterns with type safety",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/interfaces.py",
                    "reasoning": "Lines 18-27 import and use Pydantic BaseModel and Field for structured data crossing module boundaries, ensuring stable, validated schemas in provider/tool interfaces",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### Explicit Errors",
                "level": 3,
                "prompt": "Explain failing closed with actionable diagnostics and no silent fallbacks. Show code examples contrasting good (clear error with context and available options) vs bad (silent fallback with hidden behavior).",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Lines 214-220 define error handling principles: handle common errors robustly, log detailed information, provide clear messages, fail fast and visibly, never silent fallbacks",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/loader.py",
                    "reasoning": "Lines 41-44 define ModuleValidationError for explicit failure when modules fail validation, demonstrating fail-closed principle with clear error type",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 86-90 log explicit warnings when approval or display systems not provided, making missing dependencies visible rather than silently falling back, exemplifying explicit error principle",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              }
            ]
          },
          {
            "heading": "## Security Posture",
            "level": 2,
            "prompt": "Introduce the kernel's security approach covering three principles: Deny by Default, Sandbox Boundaries, and Non-Interference.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 234-238 mention security as an area to embrace complexity, and lines 62 reference capabilities/LSM showing deny-by-default security model",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": [
              {
                "heading": "### Deny by Default",
                "level": 3,
                "prompt": "Explain that kernel offers no ambient authority and modules must request capabilities explicitly. Show code example of module explicitly requesting and using capabilities.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 75 define capability registry (_capabilities dict) and the coordinator provides explicit capability registration and retrieval mechanism requiring modules to explicitly request access rather than having ambient authority",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### Sandbox Boundaries",
                "level": 3,
                "prompt": "Explain that all calls across boundaries are validated, attributed, and observable. Show code example of tool call being observable through hook emission with sanitized input and session_id.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/hooks.py",
                    "reasoning": "Lines 111-186 implement emit method showing all hook events are observable with data validation, logging, and attribution (handler names tracked), making all boundary crossings visible",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/coordinator.py",
                    "reasoning": "Lines 77-78 set default fields for all events including session_id and parent_id, ensuring all boundary-crossing events are attributed and traceable for observability",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              },
              {
                "heading": "### Non-Interference",
                "level": 3,
                "prompt": "Explain that module failures are isolated and the kernel stays up. Show code example of try/except around module execution with error emission rather than kernel crash.",
                "sources": [
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/amplifier_core/hooks.py",
                    "reasoning": "Lines 172-174 show error handling in hook execution: exceptions in hook handlers are caught, logged, but don't crash the kernel or stop other handlers from executing, demonstrating non-interference principle",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  },
                  {
                    "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                    "reasoning": "Line 292 explicitly states 'Crashing kernel on module failure (non-interference)' as an anti-pattern to avoid, establishing non-interference as a core design principle",
                    "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
                  }
                ],
                "sections": []
              }
            ]
          },
          {
            "heading": "## Red Flags",
            "level": 2,
            "prompt": "Document anti-patterns to watch for presented as a table with anti-pattern and why it's wrong: 'Add a flag for this use case' (flags accumulate; use modules), 'Pass whole context for flexibility' (violates minimal capability), 'Break API now, adoption is small' (sets bad precedent), 'Add to kernel now, figure out policy later' (policy will leak in), 'It's only one more dependency' (dependencies compound).",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 276-308 comprehensively list anti-patterns in kernel development, module development, design, and process, establishing what to resist and avoid",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": []
          },
          {
            "heading": "## North Star",
            "level": 2,
            "prompt": "Articulate the vision: Unshakeable center (kernel so small and stable it can be maintained by one person), Explosive edges (flourishing ecosystem of competing modules), Forever upgradeable (ship improvements weekly at edges, kernel updates are rare and boring).",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 372-381 define the Amplifier success criteria and summary: keeping kernel tiny/stable/boring, pushing innovation to competing modules, maintaining strong contracts, enabling observability, and trusting emergence over central planning",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": []
          },
          {
            "heading": "## References",
            "level": 2,
            "prompt": "Provide links to authoritative reference documentation: complete KERNEL_PHILOSOPHY.md document and DESIGN_PHILOSOPHY.md design principles with appropriate GitHub URLs.",
            "sources": [
              {
                "file": "https://github.com/microsoft/amplifier-core/blob/main/docs/DESIGN_PHILOSOPHY.md",
                "reasoning": "Lines 1-6 establish this as the complete design philosophy document serving as the foundational reference, and lines 48-93 detail the Linux Kernel Decision Framework that would link to additional kernel philosophy resources",
                "commit": "e0ad0bc85d43233483fc1ce15051436c474a3042"
              }
            ],
            "sections": []
          }
        ]
      }
    ]
  }
}